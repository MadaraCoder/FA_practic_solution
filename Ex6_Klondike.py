# Массив 10 строк на 10 столбцов служит игровым полем
# Map - с большой буквы чтобы не путалось с внутренней функцией пайтона (map)
Map = [[], [], [], [], [], [], [], [], [], []]

# Заполнение игрового поля нулями
row_number = 0
for row in Map:
    for column in range(10):
        row.append(0)
    # Добавляет в конце каждой строки ее номер - вертикальная разметка
    row.append(f'|{row_number}')
    row_number += 1

# Если эта переменная равна True - то сейчас ход первого игрока, если False - то второго
first_player_turn = True
# Главный игровой цикл
running = True
while running:
    # Перед выводом игрового поля, происходит вывод 15 пустых строк, чтобы предыдущее поле не мешалось с настоящим
    print('\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n')
    # Вывод каждого элемента каждой строки через разделитель ' | '
    for row in Map:
        print((' | '.join(str(col) for col in row)))
    # Затем выводится горизонтальная разметка - номер каждого столбца
    print('_________________________________________')
    print(' | '.join(str(k) for k in range(len(Map))))

    # Ввод будет происходить до тех пор, пока не будет введена свободная ячейка
    while True:
        # Если ход первого игрока, выводится просьба к ходу для первого, иначе - для второго
        if first_player_turn:
            print('\nПервый Игрок, вводите координаты точки')
        else:
            print('\nВторой Игрок, вводите координаты точки')

        # Затем вводятся координаты строки и столбца, в которую ставится отметка
        i, j = int(input('Строка: ')), int(input('Столбец: '))

        # Для начала проверяется является ли ячейка пустой
        if Map[i][j] == 0:
            # Если ход первого игрока ставится отметка - 1, если второго то - 2
            if first_player_turn:
                Map[i][j] = 1
            else:
                Map[i][j] = 2
            break
        else:
            print('\nЯчейка уже занята, попробуйте ввести другую!!! ==================================================')

    # Здесь проверка на выполнение условия окончания игры
    # P.S. я даже пытаться не буду объяснить этот кусок (говно)кода при помощи комментариев
    try:
        for r in range(len(Map)):
            for c in range(len(Map)):
                if Map[r][c] in [1, 2]:
                    for r1 in [abs(r+1), abs(r), abs(r-1)]:  # abs() предотвращает использование отрицательных индексов
                        for c1 in [abs(c-1), abs(c), abs(c+1)]:  # Отрицательные индексы будут выдавать элементы с конца
                            if Map[r1][c1] in [1, 2] and not (r1 == r and c1 == c):
                                for r2 in [r+1, r, r-1]:
                                    for c2 in [c-1, c, c+1]:
                                        if Map[r2][c2] in [1, 2] and not (r2 == r and c2 == c) and not (r2 == r1 and c2 == c1):
                                            running = False

    # Случаи с неправильным индексами будут просто игнорироваться
    except IndexError:
        pass

    # Затем происходит смена хода
    first_player_turn = not first_player_turn


# После окончания игрового цикла, поле выводится еще один раз
# -----------------------------------------------------------
# Перед выводом игрового поля, происходит вывод 15 пустых строк, чтобы предыдущее поле не мешалось с настоящим
print('\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n')
# Вывод каждого элемента каждой строки через разделитель ' | '
for row in Map:
    print((' | '.join(str(col) for col in row)))
# Затем выводится горизонтальная разметка - номер каждого столбца
print('_________________________________________')
print(' | '.join(str(i) for i in range(10)))

# По правилам игры если проигрышная комибинация попалась на ход первого игрока, то побеждает второй - и наоборот
# Но так-как в конце игрового цикла ход сменяется, вывод инвертирован
if first_player_turn:
    print('\nПервый Игрок победил!\nИгра завершена!')
else:
    print('\nВторой Игрок победил!\nИгра завершена!')
